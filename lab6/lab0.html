<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Абсолютное позиционирование</title>
  <style type="text/css">
  
  
   body { 
        background: url(http://bgfons.com/upload/paint_texture2104.jpg) no-repeat;
        -moz-background-size: 100%;
        -webkit-background-size: 100%; 
        -o-background-size: 100%; 
        background-size: 900%; 
		overflow: auto;
		
    }
  
   
   #sidebar, #content { overflow: auto; padding: 10px; }
   

   #header {
    height: 180px; /* Высота слоя */
    background: #FEDFC0; border-bottom: 2px solid #7B5427;
   }
   
   
   #hr1 {
    border: none; /* Убираем границу */
    background-color:black ; /* Цвет линии */
    color: black; /* Цвет линии для IE6-7 */
    height: 2px; /* Толщина линии */
   }
   
   #header h1 { padding: 20px; margin: 0; }
   
   
   #sidebar { 
    width: 150px; background: #ECF5E4; border-right: 1px solid #231F20;
    top: 82px; /* Расстояние от верхнего края */ 
    bottom: 0; /* Расстояние снизу  */
   }
   #content {
    top: 82px; /* Расстояние от верхнего края */
    left: 170px; /* Расстояние от левого края */ 
    bottom: 0; right: 0;
  }
  
     #content2 { 
        position: static;
        background: #ffffff;
        width: 900px;
       

        margin-top: 100px;

        margin-left: auto;
        margin-right: auto;
		 margin: 0 auto;
        outline: 2px solid #000;

        overflow: auto;
    }
  #sidebar1 {
  
		border-left:2px solid #000;
        margin-top: 83px;
        overflow: auto; 

        width: 300px; 
        height: 650px;

        float: right;

        background: #ffffff; 

        top: 100px; 
        bottom: 0; 
    }
  
  </style>
 </head>
 <body>
 
 

 
 <div id="content2"> 
 
  
 
  <div id="header"><h1> <center>  Лабораторна 6 <br> Обробка структур типу векторів і матриць, стеків та черг 
мовами функціонального програмування

	 <br> Варіант 8   </center> </h1>
   </div>
  
  <div id="content">
   <h2>  <center> Виконавець  </center>  </h2>
   <p>
   
   <table>
        <tr><td> Посада: </td> <td>  Студент  </td></tr>
		  <tr><td> Курс: </td> <td>  IV  </td></tr>
	    <tr><td> Група:   </td> <td>      ІПЗ-42 </td></tr>
		<tr><td>  ПІБ:    </td> <td>       Іваненко А.Ю </td></tr>
		<tr><td> Рік навчання: </td> <td> 2021-2022 </td></tr>
	</table>

	
   <hr id ="hr1">
  <h2>  <center> Зміст</center>  </h2>
	
	<h3><a href="#k1">Мета</a></h3>
	<h3><a href="#k2">Умова задачі</a></h3>
	<h3><a href="#k3">Структура програми</a></h3>
	<h3><a href="#k4">Обгрунтування вибору середовища</a></h3>
	<h3><a href="#k5">Код програми в коментарях</a></h3>
	<h3><a href="#k6">Посилання на проект з вихідним кодом</a></h3>
	<h3><a href="#k7">Скріншоти результатів</a></h3>
	<h3><a href="#k8">Аналіз достовірності результатів</a></h3>
	<h3><a href="#k9">Висновки</a></h3>
	
	<hr id ="hr1">


   
   <h2>  <center>  <a name="k1"></a>  Мета  </center>  </h2>
	   
   Опанувати теоретичні основи обробки структур типу векторів і матриць, стеків та черг мовами функціонального програмування та розробити програми їх реалізації
		<hr id ="hr1">  
	   
       
   <h2>  <center> <a name="k2"></a> Умови задач </center>  </h2>
   
	  <center> <h3> Задача 1 </h3> <br></center>
	8.1. Створити вектор чисел, значення яких може повторюватися. Вивести на екран кількість входжень до вектору значень кожного з його елементів, індекс та значення елемента, яке повторюється найбільшу кількість разів
	   
	 <center>  <h3> Задача 2 </h3> <br></center>
	8.2. Створити дві черги чисел, серед яких я додатні та від’ємні. Здійснити порівняння черг. Якщо черги однакові, здійснити інверсію одної з них, інакше утворити нову чергу з від’ємних елементів двох попередніх черг. 

		<hr id ="hr1">  

	
   <h2>  <center><a name="k3"></a> Структура програми  </center>  </h2>
   
	   <center>  <h3> Схема задачі 1 </h3> <br></center>
	   
	   <center><img src="sheam_1_1.png" width="400" class="round"></center> <br>

		<center>  <h3> Схема задачі 2 </h3> <br></center>
	   
		  <center><img src="sheam_1_2.png" width="800" class="round"></center> 
	   
		<hr id ="hr1">  
   
    <h2>  <center> <a name="k4"></a>Обгрунтування вибору середовища та мови функціонального програмування  </center>  </h2>
   
		<pre>
	 Online Clisp IDE https://www.jdoodle.com/execute-clisp-online/ 
	 Середовище вибране через: 
		a) -   Легкий зрозумілий інтерфес
		b) -	Не потрібно нічого  встановлювати на комп'ютер.
	 Мова Sheme вибрана через:
		а) - Лекції ведуться на цій мові.
		b) - Простий синтаксис.
		
	  </pre>
	   <hr id ="hr1">  
   
   <h2>  <center><a name="k5"></a>Код програми з коментарями   </center>  </h2>
		  <h3>  <center>Код програми 1   </center>  </h3>
		  <pre> 
		

;===========сума елементів вектора=================
(define vector-sum-abs
  (lambda (vec)
    (let ((len (vector-length vec))
          (result 0))        
      (do ((index 0 (+ index 1)))
          ((= index len) result)
        (set! result (+ result ( abs (vector-ref vec index))))))))


(define (f3 vec t a); кількість входження числа до т елемента
    (let ((summ1 0))
         (do ((index 0 (+ index 1)))
             ((= index t) summ1   )
             (if (= a (vector-ref vec index))
                 
             (set! summ1 (+ summ1 1))
                         5)
                 )
             )
        
        )
    
   


(define (f2 vec stop t n) ; створення списку списків (кількість разів зустрічі елмента перший індекс значення елементу)  
    
    (if (= t n)
        `()
        (if (= stop (vector-ref vec t))
             (f2 vec stop (+ t 1) n)
             (let 
                  (( a (vector-ref vec t))
                   ( summ1  0  ))
               ;==========================
               
               ;========================
                 (do ((index t (+ index 1)))
                     ((= index n) 
                      (if (= 0  (f3 vec t a)  )
                          (cons (list  summ1 t a  ) (f2 vec stop (+ t 1) n ))
                      (f2 vec stop (+ t 1) n )
                      
                      )
                       )
                     ( if (= a (vector-ref vec index) )
                       (set! summ1 (+ summ1 1))
                         5)
                     )
                 
                 
                 )
             
             )
        
        )
    
    
    )


(define (f5  a b a1 a2); повернення найбільшого елмента (індекс)
   
    (if (<  (vector-ref(list->vector a) 0) (vector-ref(list->vector b) 0) )
        a2
        a1
        )
    
    
    )

(define ( f1 vec); повертає найбіш зустрічаємий елемент
  
  
  ( let 
    ((  vec2  (list->vector (f2 vec (+(vector-sum-abs vec) 1) 0 (vector-length vec)  )) )
       (a 0)  )
   (display  vec2 )
   (newline)
   (do ((index 0 (+ index 1)))
        ((= index  (vector-length vec2) ) (vector-ref vec2 a) )
        (set! a (f5 (vector-ref vec2 a) (vector-ref vec2 index)   a index  ) )
       )
   
   )
    )

(newline)

(let
(( m (f1 '#(3 3 -7 -7 -7 9 9 9 9))))
(display "максимум ")
(display m) 

)
		  </pre>
			 
		  
		<h3>  <center>Код програми 2     </center>  </h3>
		  <pre>
		  
			;;#######Implimenting Stak#########
(define (make-stak)
  `()
)

(define (push_s st v)
    (append (list v) st  )
    )

(define (pop_s st )
    (cdr st)    )


(define (pop_se st )
    (car st)    )


;;#######Implimenting Queue#########
(define (make-queue)
 (define p (cons '() '() ) )
 (cons p p)
)
;========== ==Перевірка черги на пустоту==========
(define (null-queue? q)
 (and
  (eq? (front q) (rear q)) (eq? (car (front q)) '() ))
)
;===== селектор (доступ) до першого елемента черги===
(define (front q)
 (car q)) 
;==== селектор (доступ) до останнього елемента черги ==
(define (rear q)
 (cdr q))
;========додавання нового елемента в чергу=========
(define (push q e)
 (define p (cons e '()))
 (if (null-queue? q)
  (begin (set-car! q p)
   (set-cdr! q p)
  )
  (begin
   (set-cdr! (rear q) p)
   (set-cdr! q p)
  ) ) )
;========== вилучення елемента з черги============
(define (pop q)
 (define x 0)
 (if (null-queue? q)
  'Empty    ;==== виведення повідомдення про пусту чергу
  (if (and (eq? (front q) (rear q))  (eq? '() (cdr (front q)))   )
   (begin
    (set! x (car (front q)))
    (set-car! (front q) '() )
    x ) 
   (begin
    (set! x (car (front q)))
    (set-car! q (cdr (front q)) )
    x ))))

(define (copy t); створення двох  черг
    (let ((r1 (make-queue) )(r2 (make-queue)) (a 1) )
         
         (do ((index 0 (+ index 1)))
             ((null-queue? t)  (list r1 r2)  )
             (begin  
               
               (set! a (pop t))
             
               (push r1 a)
               (push r2 a)
               
              
             )
             
             )
         
         
         )
    
    )

(define (f1 a b  ); перевірка чи рівні масиви
    
    (if (or (null-queue? a) (null-queue?  b)) 
        (and (null-queue? a) (null-queue? b))
        (let ((a2 (pop a) )
              (b2 (pop b)) )
             
            (if (= a2 b2)
                (f1 a b)
                #f))
        )
    
    )

(define (f2 v1 v2 ); маін
    ;(display (copy v1) )
    (let ( ( w1  (list->vector ( copy v1   )) )  (w2  (list->vector ( copy v2   ))   ))
         
         (if (f1 (vector-ref w1 0) (vector-ref w2 0) )
             (display (f4 (f3 (vector-ref w1 1))) )
             (display (f5 (f6 (vector-ref w1 1)) (f6 (vector-ref w2 1)) )  )
             )
         
         
         )
    
    )
(define (f3 q); черга в стек
    
    (let (( r (make-stak)  ))
         
         ( do  ((index 0 (+ index 1)))
             ((null-queue? q)  r  )
             (set! r ( push_s r (pop q)    ) )
             )
         
         
         )
    
    )

(define (f4 s); стек в чергу
    
    (let ((q (make-queue)  )  (s2 s) )
         
         (do ((index 0 (+ index 1)))
              ((null? s2)  q  )
              (begin
                 ( push q (pop_se s2 ) )
                 (set! s2 (pop_s s2) )
                 
              )
             
             )
         
         
         
         )
    
    
    )


(define (f5 a b  ); злиття двох масивів 
    
      (do ((index 0 (+ index 1)))
              ((null-queue? b)  a  )
                (push a (pop b))        
             
             )
    
    
    
    )


(define (f6 a ); під масив з відємними числами
    
    (let ((rez (make-queue)) (t 1))
             
         ( do  ((index 0 (+ index 1)))
             ((null-queue? a)  rez  )
             (begin  (set! t (pop a) )
               (if (< t 0)
                 (push rez t )
                 0
                   )
                 
                )
             )
        
        )
    
   
    
    )



( let (  (a (make-queue))
         (b (make-queue)) )
     
    (push a 10) 
    (push a -11)
    (push a 12) 
    (push a 13)
    
    
    (push b 10) 
    (push b 11)
    (push b 12) 
    (push b -13)
    
   (f2 a b)
   
   ; (display  (copy a))
)






		  </pre>
		  
		  <hr id ="hr1">  
	   
		  <h2>  <center><a name="k6"></a> Посилання на проект з вихідним кодом  </center>  </h2>
		  
		  <center> <a  href="https://github.com/Andrey0277/FP_IPZ_42/tree/main"> посилання на гітхаб </a></center> 
		  
		  
		  
		  <hr id ="hr1">  
   
 <h2>  <center><a name="k7"></a> Скрішоти результаів </center>  </h2>
	     <center> <h3>  програма 1 </h3> </center>
		 
		 <center><img src="rez1_1.png" width="200" class="round">
		 
		 </center> 
		 
		 <br>
		 <center> <h3>  програма 2 </h3> </center>
		 <center><img src="rez1_2.png" width="200" class="round"></center> 
		 
		 <br>
		  
	  <center><img src="rez2_1.png" width="200" class="round"></center> 
	 <br>
	 <hr id ="hr1">  
	 
	  <h2>  <center><a name="k8"></a> Аналіз достовірності результатів </center>  </h2>
	 
	  
	  <h3> В першій та другій програмі очікуваний результат співпадає з очікуваним </h3> <br>
	  <hr id ="hr1">  
	 
	  <h2>  <center><a name="k9"></a> Висновки </center>  </h2>
	  В результаті роботи було вирішено дві заданні програмні задачі за допомогою мови Shema.<br>
	  Відсутність множин (або інформації в лабораторній роботі) доволі сильно збільшило час написання першої програми.
	 
  </div>
 </body>

</div>
</html>